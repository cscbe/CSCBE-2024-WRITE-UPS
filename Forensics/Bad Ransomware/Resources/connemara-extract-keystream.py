#!/usr/bin/env python

from __future__ import print_function

__description__ = 'Simple template'
__author__ = 'Didier Stevens'
__version__ = '0.0.1'
__date__ = '2019/08/06'

"""

Source code put in the public domain by Didier Stevens, no Copyright
https://DidierStevens.com
Use at your own risk

History:
  2019/08/06: start
  2024/02/07 added METADATATYPE_ALGO2

Todo:
"""

import optparse
import glob
import collections
import time
import sys
import textwrap
import os
import binascii
import array
import struct
import array
import fnmatch
import string
import math
import operator

def PrintManual():
    manual = '''
Manual:

This tool is to be defined.

The lines are written to standard output, except when option -o is used. When option -o is used, the lines are written to the filename specified by option -o.
Filenames used with option -o starting with # have special meaning.
#c#example.txt will write output both to the console (stdout) and file example.txt.
#g# will write output to a file with a filename generated by the tool like this: toolname-date-time.txt.
#g#KEYWORD will write output to a file with a filename generated by the tool like this: toolname-KEYWORD-date-time.txt.
Use #p#filename to display execution progress.
To process several files while creating seperate output files for each input file, use -o #s#%f%.result *.
This will create output files with the name of the inputfile and extension .result.
There are several variables available when creating separate output files:
 %f% is the full filename (with directory if present)
 %b% is the base name: the filename without directory
 %d% is the directory
 %r% is the root: the filename without extension
 %ru% is the root made unique by appending a counter (if necessary)
 %e% is the extension
Most options can be combined, like #ps# for example.
#l# is used for literal filenames: if the output filename has to start with # (#example.txt for example), use filename #l##example.txt for example.

'''
    for line in manual.split('\n'):
        print(textwrap.fill(line))

DEFAULT_SEPARATOR = ','
QUOTE = '"'

def PrintError(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

#Convert 2 Bytes If Python 3
def C2BIP3(string):
    if sys.version_info[0] > 2:
        return bytes([ord(x) for x in string])
    else:
        return string

#Convert 2 Integer If Python 2
def C2IIP2(data):
    if sys.version_info[0] > 2:
        return data
    else:
        return ord(data)

def File2Strings(filename):
    try:
        f = open(filename, 'r')
    except:
        return None
    try:
        return map(lambda line:line.rstrip('\n'), f.readlines())
    except:
        return None
    finally:
        f.close()

# CIC: Call If Callable
def CIC(expression):
    if callable(expression):
        return expression()
    else:
        return expression

# IFF: IF Function
def IFF(expression, valueTrue, valueFalse):
    if expression:
        return CIC(valueTrue)
    else:
        return CIC(valueFalse)

class cVariables():
    def __init__(self, variablesstring='', separator=DEFAULT_SEPARATOR):
        self.dVariables = {}
        if variablesstring == '':
            return
        for variable in variablesstring.split(separator):
            name, value = VariableNameValue(variable)
            self.dVariables[name] = value

    def SetVariable(self, name, value):
        self.dVariables[name] = value

    def Instantiate(self, astring):
        for key, value in self.dVariables.items():
            astring = astring.replace('%' + key + '%', value)
        return astring

class cOutput():
    def __init__(self, filenameOption=None):
        self.starttime = time.time()
        self.filenameOption = filenameOption
        self.separateFiles = False
        self.progress = False
        self.console = False
        self.fOut = None
        self.rootFilenames = {}
        if self.filenameOption:
            if self.ParseHash(self.filenameOption):
                if not self.separateFiles and self.filename != '':
                    self.fOut = open(self.filename, 'w')
            elif self.filenameOption != '':
                self.fOut = open(self.filenameOption, 'w')

    def ParseHash(self, option):
        if option.startswith('#'):
            position = self.filenameOption.find('#', 1)
            if position > 1:
                switches = self.filenameOption[1:position]
                self.filename = self.filenameOption[position + 1:]
                for switch in switches:
                    if switch == 's':
                        self.separateFiles = True
                    elif switch == 'p':
                        self.progress = True
                    elif switch == 'c':
                        self.console = True
                    elif switch == 'l':
                        pass
                    elif switch == 'g':
                        if self.filename != '':
                            extra = self.filename + '-'
                        else:
                            extra = ''
                        self.filename = '%s-%s%s.txt' % (os.path.splitext(os.path.basename(sys.argv[0]))[0], extra, self.FormatTime())
                    else:
                        return False
                return True
        return False

    @staticmethod
    def FormatTime(epoch=None):
        if epoch == None:
            epoch = time.time()
        return '%04d%02d%02d-%02d%02d%02d' % time.localtime(epoch)[0:6]

    def RootUnique(self, root):
        if not root in self.rootFilenames:
            self.rootFilenames[root] = None
            return root
        iter = 1
        while True:
            newroot = '%s_%04d' % (root, iter)
            if not newroot in self.rootFilenames:
                self.rootFilenames[newroot] = None
                return newroot
            iter += 1

    def Line(self, line, eol='\n'):
        if self.fOut == None or self.console:
            try:
                print(line, end=eol)
            except UnicodeEncodeError:
                encoding = sys.stdout.encoding
                print(line.encode(encoding, errors='backslashreplace').decode(encoding), end=eol)
#            sys.stdout.flush()
        if self.fOut != None:
            self.fOut.write(line + '\n')
            self.fOut.flush()

    def LineTimestamped(self, line):
        self.Line('%s: %s' % (self.FormatTime(), line))

    def Filename(self, filename, index, total):
        self.separateFilename = filename
        if self.progress:
            if index == 0:
                eta = ''
            else:
                seconds = int(float((time.time() - self.starttime) / float(index)) * float(total - index))
                eta = 'estimation %d seconds left, finished %s ' % (seconds, self.FormatTime(time.time() + seconds))
            PrintError('%d/%d %s%s' % (index + 1, total, eta, self.separateFilename))
        if self.separateFiles and self.filename != '':
            oFilenameVariables = cVariables()
            oFilenameVariables.SetVariable('f', self.separateFilename)
            basename = os.path.basename(self.separateFilename)
            oFilenameVariables.SetVariable('b', basename)
            oFilenameVariables.SetVariable('d', os.path.dirname(self.separateFilename))
            root, extension = os.path.splitext(basename)
            oFilenameVariables.SetVariable('r', root)
            oFilenameVariables.SetVariable('ru', self.RootUnique(root))
            oFilenameVariables.SetVariable('e', extension)

            self.Close()
            self.fOut = open(oFilenameVariables.Instantiate(self.filename), 'w')

    def Close(self):
        if self.fOut != None:
            self.fOut.close()
            self.fOut = None

def ToString(value):
    if isinstance(value, str):
        return value
    else:
        return str(value)

def Quote(value, separator, quote):
    value = ToString(value)
    if separator in value or value == '':
        return quote + value + quote
    else:
        return value

def MakeCSVLine(row, separator, quote):
    return separator.join([Quote(value, separator, quote) for value in row])

def InstantiateCOutput(options):
    filenameOption = None
    if options.output != '':
        filenameOption = options.output
    return cOutput(filenameOption)

def CalculateByteStatistics(dPrevalence=None, data=None):
    longestString = 0
    longestBASE64String = 0
    longestHEXString = 0
    base64digits = b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/'
    hexdigits = b'abcdefABCDEF0123456789'
    averageConsecutiveByteDifference = None
    if dPrevalence == None:
        dPrevalence = {iter: 0 for iter in range(0x100)}
        sumDifferences = 0.0
        previous = None
        if len(data) > 1:
            lengthString = 0
            lengthBASE64String = 0
            lengthHEXString = 0
            for byte in data:
                byte = C2IIP2(byte)
                dPrevalence[byte] += 1
                if previous != None:
                    sumDifferences += abs(byte - previous)
                    if byte >= 0x20 and byte < 0x7F:
                        lengthString += 1
                    else:
                        longestString = max(longestString, lengthString)
                        lengthString = 0
                    if byte in base64digits:
                        lengthBASE64String += 1
                    else:
                        longestBASE64String = max(longestBASE64String, lengthBASE64String)
                        lengthBASE64String = 0
                    if byte in hexdigits:
                        lengthHEXString += 1
                    else:
                        longestHEXString = max(longestHEXString, lengthHEXString)
                        lengthHEXString = 0
                else:
                    if byte >= 0x20 and byte < 0x7F:
                        lengthString = 1
                    if byte in hexdigits:
                        lengthHEXString = 1
                previous = byte
            averageConsecutiveByteDifference = sumDifferences /float(len(data)-1)
            longestString = max(longestString, lengthString)
            longestBASE64String = max(longestBASE64String, lengthBASE64String)
            longestHEXString = max(longestHEXString, lengthHEXString)
    sumValues = sum(dPrevalence.values())
    countNullByte = dPrevalence[0]
    countControlBytes = 0
    countWhitespaceBytes = 0
    countUniqueBytes = 0
    for iter in range(1, 0x21):
        if chr(iter) in string.whitespace:
            countWhitespaceBytes += dPrevalence[iter]
        else:
            countControlBytes += dPrevalence[iter]
    countControlBytes += dPrevalence[0x7F]
    countPrintableBytes = 0
    for iter in range(0x21, 0x7F):
        countPrintableBytes += dPrevalence[iter]
    countHighBytes = 0
    for iter in range(0x80, 0x100):
        countHighBytes += dPrevalence[iter]
    countHexadecimalBytes = 0
    countBASE64Bytes = 0
    for iter in range(0x30, 0x3A):
        countHexadecimalBytes += dPrevalence[iter]
        countBASE64Bytes += dPrevalence[iter]
    for iter in range(0x41, 0x47):
        countHexadecimalBytes += dPrevalence[iter]
    for iter in range(0x61, 0x67):
        countHexadecimalBytes += dPrevalence[iter]
    for iter in range(0x41, 0x5B):
        countBASE64Bytes += dPrevalence[iter]
    for iter in range(0x61, 0x7B):
        countBASE64Bytes += dPrevalence[iter]
    countBASE64Bytes += dPrevalence[ord('+')] + dPrevalence[ord('/')] + dPrevalence[ord('=')]
    entropy = 0.0
    for iter in range(0x100):
        if dPrevalence[iter] > 0:
            prevalence = float(dPrevalence[iter]) / float(sumValues)
            entropy += - prevalence * math.log(prevalence, 2)
            countUniqueBytes += 1
    if sumValues >= 256:
        entropymax = 8.0
        entropynormalized = entropy
        entropystr = '%.02f' % entropy
    else:
        entropymax = math.log(sumValues, 2)
        entropynormalized = entropy / entropymax * 8.0
        entropystr = '%.02f (normalized %.02f max %.02f)' % (entropy, entropynormalized, entropymax)
    return sumValues, entropy, entropymax, entropystr, countUniqueBytes, countNullByte, countControlBytes, countWhitespaceBytes, countPrintableBytes, countHighBytes, countHexadecimalBytes, countBASE64Bytes, averageConsecutiveByteDifference, longestString, longestHEXString, longestBASE64String, dPrevalence

def CalculateByteStatisticsNT(dPrevalence=None, data=None):
    oNT = collections.namedtuple('bytestatistics', 'sumValues entropy entropymax entropystr countUniqueBytes countNullByte countControlBytes countWhitespaceBytes countPrintableBytes countHighBytes countHexadecimalBytes countBASE64Bytes averageConsecutiveByteDifference longestString longestHEXString longestBASE64String dPrevalence')
    return oNT(*CalculateByteStatistics(dPrevalence, data))

def FindAll(data, sub):
    result = []
    start = 0
    while True:
        position = data.find(sub, start)
        if position == -1:
            return result
        result.append(position)
        start = position + 1

def ExtraInfoHEADASCII(data):
    if data == None:
        return ''
    return ''.join([IFF(b >= 32 and b < 127, chr(b), '.') for b in data])

def TrivialPrettyPrintDER(data):
    while len(data) > 0:
        if data[0] == 0x30:
            data = data[1:]
            length = data[0]
            data = data[1:]
            if length > 128:
                newlength = 0
                for iter in range(length - 128):
                    newlength = newlength * 256 + data[0]
                    data = data[1:]
                length = newlength
            print('Sequence(%d)' % length)
        elif data[0] == 0x02:
            data = data[1:]
            length = data[0]
            data = data[1:]
            if length > 128:
                newlength = 0
                for iter in range(length - 128):
                    newlength = newlength * 256 + data[0]
                    data = data[1:]
                length = newlength
            integer = data[:length]
            data = data[length:]
            print('Integer(%d) %d' % (length, int.from_bytes(integer, 'big')))

METADATATYPE_UNKNOWN = 0
METADATATYPE_ALGO1 = 1
METADATATYPE_MULTIPLE_MAGICS = 2
METADATATYPE_FULL = 3
METADATATYPE_ALGO2 = 4
METADATATYPE_FULL_ALGO2 = 5

MAGIC_PARTIAL_ENCRYPTION = b'RANSOMWARE_METADATA#'
MAGIC_FULL_ENCRYPTION_ALGO1 = b'RANSOMWARE_METADATA'
MAGIC_FULL_ENCRYPTION_ALGO2 = MAGIC_FULL_ENCRYPTION_ALGO1 + b'#'

def AddPadding(data, length=16):
    padding = length - len(data) % length
    return data + bytes([padding]) * padding
    
def AnalyzeMetadata(metadata):
    items = metadata.split(b'#')
    print('Magic:                  %s' % items[0].decode('latin'))
    testb64 = items[1]
    print('TESTB64:                %s' % testb64.decode('latin'))
    testb64 = binascii.a2b_base64(testb64)
#    testb64_16 = AddPadding(b"TESTB64@''~") # sample 22af4ef1efde7a604e0e019c6d2be02f2eec10c637d0a857d73f7cfc5e83752d.vir
    testb64_16 = AddPadding(b'TESTB64')
    testb64keystream = bytes([testb64[i] ^ testb64_16[i] for i in range(len(testb64_16))])
    print('Keystream[:16]:         %s' % binascii.b2a_hex(testb64keystream).decode('latin'))
    index = 2
    metadataType = METADATATYPE_ALGO1
    if b'$' in items[index]:
        metadataType = METADATATYPE_ALGO2
        print('Certificate:')
        for iter, item in enumerate(items[index].split(b'$')):
            hexdata = binascii.a2b_hex(item)
            if iter == 0:
                print('Item %d' % iter)
                print('Size %d' % len(hexdata))
                base64encoded = ''
                for line in hexdata.decode('latin').split('\n'):
                    line = line.rstrip('\n\r')
                    if line != '' and not '-' in line:
                        base64encoded += line
                TrivialPrettyPrintDER(binascii.a2b_base64(base64encoded))
            else:
                print('Item %d' % iter)
                print('Size %d' % len(hexdata))
                print('Entropy: %s' % CalculateByteStatisticsNT(data=hexdata).entropystr)
            print()
        index += 1
    return METADATATYPE_FULL_ALGO2, testb64keystream

def AnalyzeEncrypted(data):
    positions = FindAll(data, MAGIC_PARTIAL_ENCRYPTION)
    if len(positions) == 0:
        if data.endswith(MAGIC_FULL_ENCRYPTION_ALGO1):
            print('Magic:                  %s' % MAGIC_FULL_ENCRYPTION_ALGO1.decode('latin'))
            return [METADATATYPE_FULL]
        else:
            positions = FindAll(data, MAGIC_FULL_ENCRYPTION_ALGO2)
            if len(positions) == 0:
                return [METADATATYPE_UNKNOWN]
            elif len(positions) == 1:
                result = AnalyzeMetadata(data[positions[0]:])
                return result[0], data[:positions[0]], len(data[:positions[0]]), 0, 1, result[1], b''
            else:
                return METADATATYPE_MULTIPLE_MAGICS, positions
    elif len(positions) == 1:
        trailer = data[positions[0]:]
        items = trailer.split(b'#')
        print('Magic:                  %s' % items[0].decode('latin'))
        testb64 = items[1]
        print('TESTB64:                %s' % testb64.decode('latin'))
        testb64 = binascii.a2b_base64(testb64)
#        testb64_16 = AddPadding(b"TESTB64@''~") # sample 22af4ef1efde7a604e0e019c6d2be02f2eec10c637d0a857d73f7cfc5e83752d.vir
        testb64_16 = AddPadding(b'TESTB64')
        testb64keystream = bytes([testb64[i] ^ testb64_16[i] for i in range(len(testb64_16))])
        print('Keystream[:16]:         %s' % binascii.b2a_hex(testb64keystream).decode('latin'))
        index = 2
        metadataType = METADATATYPE_ALGO1
        if b'$' in items[index]:
            metadataType = METADATATYPE_ALGO2
            print('Certificate:')
            for iter, item in enumerate(items[index].split(b'$')):
                hexdata = binascii.a2b_hex(item)
                if iter == 0:
                    print('Item %d' % iter)
                    print('Size %d' % len(hexdata))
                    base64encoded = ''
                    for line in hexdata.decode('latin').split('\n'):
                        line = line.rstrip('\n\r')
                        if line != '' and not '-' in line:
                            base64encoded += line
                    TrivialPrettyPrintDER(binascii.a2b_base64(base64encoded))
                else:
                    print('Item %d' % iter)
                    print('Size %d' % len(hexdata))
                    print('Entropy: %s' % CalculateByteStatisticsNT(data=hexdata).entropystr)
                print()
            index += 1
        ranges = items[index:]
        start, blocksize = [int(x) for x in ranges[0].decode('latin').split(':')]
        stepsize, blocksize_ = [int(x) for x in ranges[1].decode('latin').split(':')]
        stepsize = stepsize - start
        if start != 0:
            print('Start is not 0: %d' % start)
        headerDecrypted = bytes([data[i + start] ^ testb64keystream[i] for i in range(len(testb64_16))])
        print('Decrypted header:       %s' % binascii.b2a_hex(headerDecrypted).decode('latin'))
        print('Decrypted header ASCII: %s' % ExtraInfoHEADASCII(headerDecrypted))
        print('blocksize:       %10d' % blocksize)
        print('stepsize:        %10d' % stepsize)
        start = 0
        for range_ in ranges:
            range_ = range_.decode('latin')
            rangeExpected = '%d:%d' % (start, blocksize)
            start += stepsize
            if range_ != rangeExpected:
                print('Unexpected range: %s (expected %s)' % (range_, rangeExpected))
        numberofblocks = len(ranges)
        print('numberofblocks:  %10d' % numberofblocks)
        return metadataType, data[:positions[0]], blocksize, stepsize, numberofblocks, testb64keystream, headerDecrypted
    else:
        return METADATATYPE_MULTIPLE_MAGICS, positions

def AlgoVersion2Sub(length, numberofblocks=10):
    blocksize = round(length / (numberofblocks * 10)) & 0xFFFFFFFFF0
    stepsize = int(length / numberofblocks)
    return blocksize, stepsize, numberofblocks

def AlgoVersion2(length):
    if length <= 512 * 1024 * 1024:
        return AlgoVersion2Sub(length)
    else:
        return AlgoVersion2Sub(length, 1000)

def ParsePK0102(data):
    data0 = data[:4]
    if data0 != b'PK\x01\x02':
        return None, None, None, None
    data0 = b'PK\x03\x04'
    data1 = data[6:8]
    data2 = data[8:30]
    filelength = struct.unpack('<H', data[28:30])[0]
    extralength = struct.unpack('<H', data[30:32])[0]
    offset = struct.unpack('<I', data[42:46])[0]
    data3 = data[46:46+filelength]
    data = data[46+filelength+extralength:]
    return data0 + data1 + data2, data3, offset, data

def ParsePK0102s(data):
    result = []
    while True:
        pk0304a, pk0304b, offset, remainder = ParsePK0102(data)
        if pk0304a == None or remainder == b'':
            break
        data = remainder
        result.append([offset, pk0304a, pk0304b])
    return result

def Encrypted(position, ranges):
    for range in ranges:
        if position >= range[0] and position <= range[1]:
            return position - range[0]
    return -1

def ExtractZIP(data, keystream):
    result = AnalyzeEncrypted(data)
    if result[0] not in [METADATATYPE_ALGO1, METADATATYPE_ALGO2]:
        return
    dummy, data, blocksize, stepsize, numberofblocks, testb64keystream, headerDecrypted = result
    if result[0] == METADATATYPE_ALGO1 and headerDecrypted[:4] != b'PK\x03\x04':
        return
    ranges = []
    for i in range(numberofblocks):
        ranges.append([i*stepsize, i*stepsize+blocksize-1])
    positionEnd = data.rfind(b'PK\x05\x06')
    directorySize, directoryOffset = struct.unpack('<II',data[positionEnd+12:positionEnd+12+8])
    PK0304s = ParsePK0102s(data[directoryOffset:directorySize+directoryOffset])
    for position, PK0304a, PK0304b in PK0304s:
        if Encrypted(position, ranges) != -1 or Encrypted(position+len(PK0304a)+len(PK0304b)+1, ranges) != -1:
            for i in range(len(PK0304a)):
                keystreamIndex = Encrypted(position + i, ranges)
                if keystreamIndex == -1:
                    continue
                keybyte = data[position+i] ^ PK0304a[i]
                if keystream[keystreamIndex] != -1 and keystream[keystreamIndex] != keybyte:
#                    raise
                    return
                keystream[keystreamIndex] = keybyte
            for i in range(len(PK0304b)):
                keystreamIndex = Encrypted(position + len(PK0304a) + 2 + i, ranges)
                if keystreamIndex == -1:
                    continue
                keybyte = data[position + len(PK0304a) + 2 + i] ^ PK0304b[i]
                if keystream[keystreamIndex] != -1 and keystream[keystreamIndex] != keybyte:
#                    raise
                    return
                keystream[keystreamIndex] = keybyte

def File2String(filename):
    try:
        f = open(filename, 'rb')
    except:
        return None
    try:
        return f.read()
    except:
        return None
    finally:
        f.close()

def ProcessAt(argument):
    if argument.startswith('@'):
        strings = File2Strings(argument[1:])
        if strings == None:
            raise Exception('Error reading %s' % argument)
        else:
            return strings
    else:
        return [argument]

def Glob(filename):
    filenames = glob.glob(filename)
    if len(filenames) == 0:
        return [filename]
    else:
        return filenames

class cExpandFilenameArguments():
    def __init__(self, filenames, literalfilenames=False, recursedir=False, checkfilenames=False, expressionprefix=None, flagprefix=None):
        self.containsUnixShellStyleWildcards = False
        self.warning = False
        self.message = ''
        self.filenameexpressionsflags = []
        self.expressionprefix = expressionprefix
        self.flagprefix = flagprefix
        self.literalfilenames = literalfilenames

        expression = ''
        flag = ''
        if len(filenames) == 0:
            self.filenameexpressionsflags = [['', '', '']]
        elif literalfilenames:
            self.filenameexpressionsflags = [[filename, '', ''] for filename in filenames]
        elif recursedir:
            for dirwildcard in filenames:
                if expressionprefix != None and dirwildcard.startswith(expressionprefix):
                    expression = dirwildcard[len(expressionprefix):]
                elif flagprefix != None and dirwildcard.startswith(flagprefix):
                    flag = dirwildcard[len(flagprefix):]
                else:
                    if dirwildcard.startswith('@'):
                        for filename in ProcessAt(dirwildcard):
                            self.filenameexpressionsflags.append([filename, expression, flag])
                    elif os.path.isfile(dirwildcard):
                        self.filenameexpressionsflags.append([dirwildcard, expression, flag])
                    else:
                        if os.path.isdir(dirwildcard):
                            dirname = dirwildcard
                            basename = '*'
                        else:
                            dirname, basename = os.path.split(dirwildcard)
                            if dirname == '':
                                dirname = '.'
                        for path, dirs, files in os.walk(dirname):
                            for filename in fnmatch.filter(files, basename):
                                self.filenameexpressionsflags.append([os.path.join(path, filename), expression, flag])
        else:
            for filename in list(collections.OrderedDict.fromkeys(sum(map(self.Glob, sum(map(ProcessAt, filenames), [])), []))):
                if expressionprefix != None and filename.startswith(expressionprefix):
                    expression = filename[len(expressionprefix):]
                elif flagprefix != None and filename.startswith(flagprefix):
                    flag = filename[len(flagprefix):]
                else:
                    self.filenameexpressionsflags.append([filename, expression, flag])
            self.warning = self.containsUnixShellStyleWildcards and len(self.filenameexpressionsflags) == 0
            if self.warning:
                self.message = "Your filename argument(s) contain Unix shell-style wildcards, but no files were matched.\nCheck your wildcard patterns or use option literalfilenames if you don't want wildcard pattern matching."
                return
        if self.filenameexpressionsflags == [] and (expression != '' or flag != ''):
            self.filenameexpressionsflags = [['', expression, flag]]
        if checkfilenames:
            self.CheckIfFilesAreValid()

    def Glob(self, filename):
        if not ('?' in filename or '*' in filename or ('[' in filename and ']' in filename)):
            return [filename]
        self.containsUnixShellStyleWildcards = True
        return glob.glob(filename)

    def CheckIfFilesAreValid(self):
        valid = []
        doesnotexist = []
        isnotafile = []
        for filename, expression, flag in self.filenameexpressionsflags:
            hashfile = False
            try:
                hashfile = FilenameCheckHash(filename, self.literalfilenames)[0] == FCH_DATA
            except:
                pass
            if filename == '' or hashfile:
                valid.append([filename, expression, flag])
            elif not os.path.exists(filename):
                doesnotexist.append(filename)
            elif not os.path.isfile(filename):
                isnotafile.append(filename)
            else:
                valid.append([filename, expression, flag])
        self.filenameexpressionsflags = valid
        if len(doesnotexist) > 0:
            self.warning = True
            self.message += 'The following files do not exist and will be skipped: ' + ' '.join(doesnotexist) + '\n'
        if len(isnotafile) > 0:
            self.warning = True
            self.message += 'The following files are not regular files and will be skipped: ' + ' '.join(isnotafile) + '\n'

    def Filenames(self):
        if self.expressionprefix == None:
            return [filename for filename, expression, flag in self.filenameexpressionsflags]
        else:
            return self.filenameexpressionsflags

def ProcessXOR16(info):
    metadataType, data, blocksize, stepsize, numberofblocks, testb64keystream, headerDecrypted = info
    dStats = { index: {} for index in range(16) }
    for blockIter in range(numberofblocks):
        for index in range(blocksize):
            value = data[blockIter * stepsize + index]
            for keyvalue in range(256):
                valueXored = value ^ keyvalue
                if valueXored >= 0x20 and valueXored < 0x7F or valueXored in [0x0A, 0x0D]:
                    dStats[index % 16][keyvalue] = dStats[index % 16].get(keyvalue, 0) + 1

    keyHex = ''
    aBytes = []
    combinations = 1
    for index in range(16):
        sortedStats = sorted(dStats[index].items(), key=operator.itemgetter(1))
        keybyte, frequenty = sortedStats[-1]
        keybytes = [b for b, f in sortedStats if f == frequenty]
        print(frequenty, keybytes)
        keyHex += '%02x' % keybyte
        aBytes.append(keybyte)
        combinations *= len(keybytes)
    print('Combinations: %s' % combinations)
    print(keyHex)
    return bytes(aBytes)

def ProcessArguments(args, options):
    oOutput = InstantiateCOutput(options)

    if options.zip:
        keystream = array.array('h', [-1 for i in range(20000000)])
        oExpandFilenameArguments = cExpandFilenameArguments(args, False, True, False, '#c#', '#f#')
        print()
        fileSizes = []
        for arg, _, _ in oExpandFilenameArguments.Filenames():
            print(arg)
            with open(arg, 'rb') as fIn:
                filecontent1 = fIn.read()
            ExtractZIP(filecontent1, keystream)
            result1 = AnalyzeEncrypted(filecontent1)
            fileSizes.append(len(filecontent1))
        keystreamHex = []
        counter = 0
        for keybyte in keystream:
            if keybyte == -1:
                keystreamHex.append('..')
            else:
                keystreamHex.append('%02x' % keybyte)
                counter += 1
        keystreamHex = ''.join(keystreamHex)
        if result1[0] == METADATATYPE_ALGO1:
            print('Keystream:')
            print(keystreamHex.rstrip('.'))
            print('Processed files: %d' % len(fileSizes))
            print('Minimum file size: %d' % min(fileSizes))
            print('Maximum file size: %d' % max(fileSizes))
            print('Recovered keystream bytes: %d Size keystream array: %d' % (counter, len(keystream)))
            usableKeystream = keystream[:keystream.index(-1)]
            print('Size usable keystream: %d' % len(usableKeystream))
            print('Maximum file size that can be decrypted: %d' % (len(usableKeystream) * 100))
            if options.write != '':
                with open(options.write, 'wb') as fOut:
                    fOut.write(bytes([b for b in usableKeystream]))
        elif result1[0] == METADATATYPE_ALGO2:
            print('16 byte Key:')
            print('First:  %s' % keystreamHex[:32])
            print('Repeat: %s' % keystreamHex[32:64])
            if options.write != '':
                with open(options.write, 'wb') as fOut:
                    fOut.write(bytes([b for b in keystream[:16]]))
        return

    if len(args) < 1 and len(args) > 3:
        print('Provide 1 file (encrypted) or 2 files (encrypted and unencrypted) and an optional filename to store te keystream')
        return

    with open(args[0], 'rb') as fIn:
        filecontent1 = fIn.read()

    result1 = AnalyzeEncrypted(filecontent1)
    if result1[0] in [METADATATYPE_ALGO2, METADATATYPE_FULL_ALGO2]:
        xorkey = ProcessXOR16(result1)
        if len(args) == 2:
            with open(args[1], 'wb') as fOut:
                fOut.write(xorkey)
                print('\nWrote keystream to file %s' % args[1])
        return
    result1b = AlgoVersion2(len(result1[1]))
    print()
    print('Calculation encrypted:')
    print(' blocksize:      %10d' % result1b[0])
    print(' stepsize:       %10d' % result1b[1])
    print(' numberofblocks: %10d' % result1b[2])
    if result1[2:5] != result1b:
        raise Exception('Difference!')

    if len(args) == 1:
            return

    with open(args[1], 'rb') as fIn:
        filecontent2 = fIn.read()

    result2 = AnalyzeEncrypted(filecontent2)

    if not result1[0] in [METADATATYPE_ALGO1, METADATATYPE_ALGO2]:
        print('%s has no encryption trailer' % args[0])

    if result2[0] in [METADATATYPE_ALGO1, METADATATYPE_ALGO2]:
        print('%s has encryption trailer' % args[1])

    if result1[0] == METADATATYPE_ALGO1 and result2[0] == 0:
        filecontent1 = result1[1]
        if len(filecontent1) != len(filecontent2):
            print('Files have different lengths!')
            return

    blocksize, stepsize, numberofblocks = AlgoVersion2(len(filecontent1))

    print()
    print('Calculation unencrypted:')
    print(' blocksize:      %10d' % blocksize)
    print(' stepsize:       %10d' % stepsize)
    print(' numberofblocks: %10d' % numberofblocks)

    baData = bytearray(blocksize)
    for i in range(blocksize):
        baData[i] = filecontent1[i] ^ filecontent2[i]

    for step in range(1, numberofblocks):
        for i in range(blocksize):
            if baData[i] != filecontent1[step * stepsize + i] ^ filecontent2[step * stepsize + i]:
                print('Error keystream')
                return

    print()
    print('Maximum file size that can be decrypted: %d' % (len(baData) * 100))

    if len(args) == 3:
        with open(args[2], 'wb') as fOut:
            fOut.write(baData)
            print('\nWrote keystream to file %s' % args[2])

    oOutput.Close()

def Main():
    moredesc = '''

Arguments:
@file: process each file listed in the text file specified
wildcards are supported

Source code put in the public domain by Didier Stevens, no Copyright
Use at your own risk
https://DidierStevens.com'''

    oParser = optparse.OptionParser(usage='usage: %prog [options] [[@]file ...]\n' + __description__ + moredesc, version='%prog ' + __version__)
    oParser.add_option('-m', '--man', action='store_true', default=False, help='Print manual')
    oParser.add_option('-o', '--output', type=str, default='', help='Output to file (# supported)')
    oParser.add_option('-z', '--zip', action='store_true', default=False, help='Process ZIP files')
    oParser.add_option('-w', '--write', type=str, default='', help='Filename keystream')
    (options, args) = oParser.parse_args()

    if options.man:
        oParser.print_help()
        PrintManual()
        return

    ProcessArguments(args, options)

if __name__ == '__main__':
    Main()
